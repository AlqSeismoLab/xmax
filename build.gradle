import groovy.json.JsonSlurper
import java.text.SimpleDateFormat

plugins {
    id 'java'
    id 'application'
    id 'java-library'
    id 'idea'
}

mainClassName = "com.isti.xmax.XMAX"

/* Get first three version numbers from code.json */
def codeJson = new JsonSlurper().parseText(new File("code.json").text)
// NOTE: codeJson.version is a String[], and any IDE warning here can be safely ignored
def jsonVersion = codeJson.version[0]
/* Get last version number from commit counts */
def lastTagHash = "git rev-list --tags --max-count=1".execute().text
lastTagHash = lastTagHash.substring(0, lastTagHash.length() - 1)
def commitCount = ("git rev-list "+lastTagHash+".. --count").execute().text
commitCount = commitCount.substring(0, commitCount.length() - 1)

def version = "$jsonVersion.$commitCount"


sourceCompatibility = '1.8'
targetCompatibility = '1.8'

repositories {
    mavenCentral()
    maven {
        // used to use http:, but that is not going to be supported in gradle 7
        url "https://www.seis.sc.edu/software/maven2"
    }
}

dependencies {
    // this will include seisfile, seedcodec, and commons math3 as dependencies, hence 'api' tag
    // to allow access to those by the project as necessary
    api project(':asl-java-utils')
    // jevalresp here uses jaxb stuff and includes some additional edu.seis stuff (fissuresIDL)
    api files('./lib/JEvalResp.jar', './lib/ekit-1.4.jar')

    // some library components require xml bindings to function which we'll include explicitly here
    // (in particular stuff related to picks and the jevalresp library)
    implementation group: 'javax.xml.bind', name: 'jaxb-api', version: '2.3+'
    implementation group: 'com.sun.xml.bind', name: 'jaxb-core', version: '2.3+'
    implementation group: 'com.sun.xml.bind', name: 'jaxb-impl', version: '2.3+'
    implementation group: 'com.sun.activation', name: 'javax.activation', version: '1.2.0'

    // both of these jfree libraries are also in fissuresUtil so may want to tag that as 'api'
    // and not 'implementation'
    implementation group: 'org.jfree', name: 'jfreechart', version: '1.0.+'
    implementation group: 'org.jfree', name: 'jcommon', version: '1.0.+'

    // note that this would be redundant if we declare commons-math3 as an api in asl-java-utils
    implementation group: 'org.apache.commons', name: 'commons-math3', version: '3.6.1'

    implementation group: 'commons-cli', name: 'commons-cli', version: '1.2'
    implementation group: 'commons-configuration', name: 'commons-configuration', version: '1.7'
    implementation group: 'commons-codec', name: 'commons-codec', version: '1.5'
    implementation group: 'commons-lang', name: 'commons-lang', version: '2.6'
    implementation group: 'commons-collections', name: 'commons-collections', version: '3.2.1'
    implementation group: 'commons-logging', name: 'commons-logging', version: '1.1.1'
    implementation group: 'org.jdom', name: 'jdom', version: '1.1'
    implementation group: 'edu.emory.mathcs', name: 'JTransforms', version: '2.4'
    implementation group: 'log4j', name: 'log4j', version: '1.2.16' // redundant, possibly
    implementation group: 'org.reflections', name: 'reflections', version: '0.9.10'
    implementation group: 'edu.iris.dmc', name: 'java-seed', version: '3.8.5'
    // in TransformationUtils.java which might be replaceable with asl-java-utils filter mthds
    implementation group: 'uk.me.berndporr', name: 'iirj', version: '1.0'

    implementation group: 'edu.sc.seis', name: 'TauP', version: '2.4.5'

    //seis.sc.edu maven dependencies

    // note that when compiling jar we choose to exclude duplicate dependencies, so while
    // fissuresUtil here has previously-cited libraries, we don't need to manually exclude them
    // (these libraries are jfreechart, jcommon, and fissuresIDL -- note that fissuresIDL is
    //  bundled in jevalresp which is included as an API and thus already available)
    implementation group: 'edu.sc.seis', name: 'fissuresUtil', version: '1.1.5'
    implementation group: 'xerces', name: 'xml-apis', version: '2.10.0'

    testImplementation group: 'junit', name: 'junit', version: '4.+'
}



jar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    /* Adds all dependent libraries*/
    dependsOn configurations.runtimeClasspath
    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
    dependsOn configurations.compileClasspath
    from {
        configurations.compileClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }

    archiveVersion = version
    archiveBaseName = rootProject.name

    manifest {
        attributes 'Implementation-Title': 'XMAX',
                   'Implementation-Version': archiveVersion,
                   'Main-Class': mainClassName,
                   'Build-Timestamp': new SimpleDateFormat("yyyy.MM.dd").format(new Date())
    }
}

/*Turn off doclint since it is far too strict and breaks the javadoc everytime*/
if (JavaVersion.current().isJava8Compatible()) {
    allprojects {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
}

task copyJar(type: Copy) {
    from jar
    into rootDir
}

test {
    maxHeapSize = "4096m"
    maxParallelForks = 4
    testLogging {
        events "skipped", "failed"
        exceptionFormat "full"
        afterSuite { desc, result ->
            if (!desc.parent) {
                println "Result: ${result.resultType} (${result.testCount} tests, " +
                        "${result.successfulTestCount} successes, ${result.failedTestCount} " +
                        "failures, ${result.skippedTestCount} skipped)"
            }
        }
    }
}

gradle.beforeProject {
    println("Perform pre-project setup")
    def sout = new StringBuilder()
    def serr = new StringBuilder()
    println("Updating gitsubmodules")
    def proc = "git submodule update --init --recursive".execute()
    proc.consumeProcessOutput(sout, serr)
    proc.waitFor()
    print sout
    print serr
    sout = new StringBuilder()
    serr = new StringBuilder()
    println("Updating JEvalResp")
    proc = "./jevalresp_setup.bash".execute()
    proc.consumeProcessOutput(sout, serr)
    proc.waitFor()
    print sout
    print serr

    println("Done with pre-project setup")
}

build.dependsOn(copyJar)

javadoc {
    options.memberLevel = JavadocMemberLevel.PRIVATE
}


